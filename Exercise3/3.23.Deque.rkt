#lang sicp

; deque: double ended queue, (front-node. rear-node)
(define (make-deque) (cons nil nil))
(define (empty-deque? q) (null? (front-node-deque q)))
(define (front-deque q) (value-node (front-node-deque q)))
(define (rear-deque q) (value-node (rear-node-deque q)))

; auxiliary procedures
(define (deque-only-one-element? q) (eq? (front-node-deque q) (rear-node-deque q)))
(define (front-node-deque q) (car q))
(define (rear-node-deque q) (cdr q))
(define (set-deque-front! q value) (set-car! q value))
(define (set-deque-rear! q value) (set-cdr! q value))

; node of deque (just like a double-direction linked list)
(define (make-node prev value next) (list 'node prev value next))
(define (prev-node node) (cadr node))
(define (value-node node) (caddr node))
(define (next-node node) (cadddr node))
(define (set-node-prev! node value) (set-car! (cdr node) value))
(define (set-node-next! node value) (set-car! (cdddr node) value))

; use a list of node to construct deque
; all return values are unspecified
(define (front-insert-deque! q value)
    (let ((new-node (make-node nil value nil)))
        (cond ((empty-deque? q) (set-deque-front! q new-node)
                                (set-deque-rear! q new-node))
              (else (set-node-next! new-node (front-node-deque q))
                    (set-node-prev! (front-node-deque q) new-node)
                    (set-deque-front! q new-node))
        )
    )
)
(define (rear-insert-deque! q value)
    (let ((new-node (make-node nil value nil)))
        (cond ((empty-deque? q) (set-deque-front! q new-node)
                                (set-deque-rear! q new-node))
              (else (set-node-next! (rear-node-deque q) new-node)
                    (set-node-prev! new-node (rear-node-deque q))
                    (set-deque-rear! q new-node))
        )
    )
)
(define (front-delete-deque! q)
    (cond ((empty-deque? q) (error "Delete front from an empty deque."))
          ((deque-only-one-element? q) (set-deque-front! q nil)
                                       (set-deque-rear! q nil)) ; only one element
          (else (set-deque-front! q (next-node (front-node-deque q)))
                (set-node-prev! (front-node-deque q) nil))
    )
)
(define (rear-delete-deque! q)
    (cond ((empty-deque? q) (error "Delete rear from an empty deque."))
          ((deque-only-one-element? q) (set-deque-front! q nil)
                                       (set-deque-rear! q nil)) ; only one element
          (else (set-deque-rear! q (prev-node (rear-node-deque q)))
                (set-node-next! (rear-node-deque q) nil))
    )
)
(define (print-deque q)
    (define (iter node)
        (if (not (null? node))
            (begin (display (value-node node))
                   (display " ")
                   (iter (next-node node))
            )
        )
    )
    (display "#deque front ... rear : ")
    (iter (front-node-deque q))
    (newline)
)


; test
(define q (make-deque))
(print-deque q)
(empty-deque? q)
(front-insert-deque! q 1)
(front-insert-deque! q 2)
(front-insert-deque! q 3)
(rear-insert-deque! q 10)
(rear-insert-deque! q 100)
(rear-insert-deque! q 1000)
(print-deque q)

(front-deque q)
(rear-deque q)

(front-delete-deque! q)
(rear-delete-deque! q)
(rear-delete-deque! q)
(print-deque q)
(empty-deque? q)